import{l as N,r as $,b as k,v as R,c as P}from"./three.module.62571882.js";import{c as z}from"./dom.be162d4e.js";import{GamePad as B}from"./Gamepad.8a108b30.js";import{GameLoop as G}from"./GameLoop.699b6383.js";class L{constructor(t,s=0,n=0){this.ctx=t,this.x=s,this.y=n,this.fontSize=16,this.lineSize=1.1,this.style="rgba(255, 255, 220, .75)",this.py=0,this.reset()}reset(){this.py=this.y}print(t="",s=1){const{ctx:n,style:r,fontSize:e,lineSize:f}=this;return n.save(),n.font=`${e*s}px Courier`,n.textBaseline="top",n.textAlign="left",n.fillStyle=r,n.fillText(t,this.x,this.py),this.py+=e*f*s,n.restore(),this}}class D{constructor(t){this.ctx=t,this.text=new L(t,24,24),this.text.fontSize=14}render(){const{ctx:t,gw:s,gh:n}=this;t.fillStyle="rgba(0, 0, 0, .5)",t.fillRect(0,0,s,n),this.renderNetwork()}renderNetwork(){const{text:t,ctx:s,gw:n,gh:r,network:e}=this;if(!e)return;const{inputs:f,outputs:a,hiddenLayers:c,layers:u}=e;t.reset(),t.print(e.name,1.5);const l=c.reduce((h,m)=>h*m,f*a);t.print(`Tensor size: ${l}`),u.forEach((h,m)=>{t.print(`Layers ${m} have ${h.length} units`)}),t.print(`Score: ${e.score.toFixed(10)}`),this.entity&&(t.print(`x: ${this.entity.x}`),t.print(`y: ${this.entity.y}`),t.print(`angle: ${this.entity.a}`))}get gw(){return this.ctx.canvas.width}get gh(){return this.ctx.canvas.height}getHue(t){return Math.round(N(270,180,(t+1)/2))}}const b=3,I=Array(b).fill(0).map((i,t)=>N(0,360,(t+1)/b));function A(i,t){const s=i+t;return s>b-1?0:s<0?b-1:s}class j{constructor(t){this.weight=0,this.bias=0,Object.assign(this,t)}}class _{constructor(t,s=1,n=[5],r=0,e=0){this.inputs=t,this.outputs=s,this.hiddenLayers=n,this.generation=r,this.mutationAmount=e,this.layers=[],this.score=0,this.name=`Network ${[this.inputs,...this.hiddenLayers,this.outputs].join(".")}`,this.layers=[t,...n,s].map(f=>new Array(f).fill(0).map(()=>new j({bias:0,weight:0}))),this.randomize(1)}loadFromFile(t){const s=localStorage.getItem(t),n=JSON.parse(s);return this.fromObject(n),n}saveToFile(t){localStorage.setItem(t,this.toJSON())}fromObject(t){Object.assign(this,t)}toJSON(){const t={score:this.score,generation:this.generation,layers:this.layers};return JSON.stringify(t,null,2)}train(t,s=1e3){const n=[];for(let r=1;r<=s;r++){const[e,f]=t(),a=this.clone(r/s),c=this.feedForward(e),u=f.reduce((l,h)=>l+Math.abs(f[h]-c[h]),0);console.log({inputs:e,expected:f,results:c,distance:u}),n.push({network:a,mutation:a.mutationAmount,distance:u})}return n.sort((r,e)=>r.distance-e.distance),console.table(n.map(r=>r.distance)),n}clone(t=this.mutationAmount){return new _(this.inputs,this.outputs,this.hiddenLayers,this.generation+1,t)}feedForward(t,s=0){const n=this.layers[s];if(!n)return t;const r=n.map(e=>t.reduce((f,a)=>{const c=e.weight*a;return c>e.bias?c:f},0));return this.feedForward(r,s+1)}randomize(t=this.mutationAmount){for(let s=0;s<this.layers.length;s++){const n=this.layers[s];for(let r=0;r<n.length;r++){const e=n[r];e.bias=N(e.bias,$(-1,1),t),e.weight=N(e.weight,$(-1,1),t)}}}}const d=class{constructor(i={}){this.faction=k(0,b-1),this.label=this.faction+"",this.x=0,this.y=0,this.vx=0,this.vy=0,this.a=0,this.va=0,this.s=0,this.focused=!1,this.dead=!1,this.others=[],this.energy=100,this.atk=0,this.vatk=0,this.age=0,this.scorediff=0,this.score=0,this.brain=new _(d.MAX_NB*2,3,[d.MAX_NB,5]),Object.assign(this,i)}forward(){this.vx+=Math.cos(this.a)*.2,this.vy+=Math.sin(this.a)*.2,this.brain.score+=.1}turnLeft(){this.va-=.02}turnRight(){this.va+=.02}get radius(){return d.RADIUS+this.energy/20}kill(){this.dead=!0}update(){this.s*=.99,this.va*=.8,this.vx*=.9,this.vy*=.9,this.vatk*=.9,this.atk=(this.atk+this.vatk)*.7,!this.dead&&(this.energy-=this.s/50,this.energy-=this.va/100,this.x+=this.vx,this.y+=this.vy,this.a+=this.va,this.a>Math.PI&&(this.a-=Math.PI*2),this.a<-Math.PI&&(this.a+=Math.PI*2),this.brain.score<-25&&this.kill(),this.age+=.01,this.age>100&&(this.brain.score-=1))}getTensorScore(){return this.others?this.others.reduce((i,t,s)=>i-t.distance*t.opportunity/(s+1),0):0}updateTargets(i,t,s){if(this.others=[],this.dead)return;for(let r=0;r<i.length;r++){const e=i[r];if(e.dead||e.faction===this.faction)continue;const f=R(this.x-e.x,this.y-e.y);let a=0;const c=A(this.faction,1)===e.faction,u=A(this.faction,-1)===e.faction;c&&a--,u&&a++;let l=e.x,h=e.y;l-this.x>t/2&&(l-=t),l-this.x<t/-2&&(l+=t),this.y-h<s/-2&&(h-=s),this.y-h>s/2&&(h+=s),this.others.push({x:l,y:h,distance:f,opportunity:a}),!(this.age<d.MIN_AGE_TO_INTERACT||e.age<d.MIN_AGE_TO_INTERACT)&&f<this.radius+e.radius&&(A(this.faction,1)===e.faction&&(this.brain.score-=10),A(this.faction,-1)===e.faction&&(e.kill(),this.brain.score+=10))}this.others.sort((r,e)=>r.distance-e.distance);const n=this.score;this.score=this.getTensorScore(),this.scorediff=n-this.score,this.brain.score+=this.scorediff/10}draw(i){this.focused&&this.drawSensors(i),this.drawBody(i),this.drawScore(i)}drawBody(i){const t=this.focused?1:.51,s=A(this.faction,-1),n=Math.PI*.1,r=this.age>d.SENIOR_AGE?"80%":"50%";i.lineWidth=3,i.strokeStyle=`hsla(${I[this.faction]}, 100%, 70%, ${t})`,i.fillStyle=`hsla(${I[this.faction]}, 100%,${r}, ${t})`,i.save(),i.translate(this.x,this.y),i.rotate(this.a),i.beginPath(),i.moveTo(this.radius*.5,0),i.arc(0,0,this.radius,n,Math.PI*2-n),i.lineTo(this.radius*.5,0),i.stroke(),this.age>d.MIN_AGE_TO_INTERACT&&i.fill(),i.beginPath(),i.strokeStyle=`hsla(${I[s]}, 100%, 80%, ${t})`,i.fillStyle=`hsla(${I[s]}, 100%, 20%, ${t})`,i.lineTo(0,0),i.lineTo(this.radius+5,0),i.stroke(),i.fill(),i.restore()}drawSensors(i){i.setLineDash([3,3]),i.lineWidth=2,this.others.slice(0,d.TRACK_NB).forEach((t,s)=>{const n=1/(1+s);i.beginPath(),i.strokeStyle=t.opportunity>0?`rgba(0, 255, 0, ${n})`:`rgba(255, 128, 0, ${n})`,i.moveTo(this.x,this.y),i.lineTo(t.x,t.y),i.stroke();const r=P(this.x-t.x,this.y-t.y);i.fillStyle="black",i.fillText(r.toFixed(1),t.x,t.y)}),i.setLineDash([])}drawScore(i){i.fillStyle="white",i.textAlign="center",i.textBaseline="middle";const t=this.y>d.RADIUS*5?this.y-d.RADIUS*2:this.y+d.RADIUS*2;i.fillText(`${this.score.toFixed(0)}`,this.x,t)}};let y=d;y.TRACK_NB=1;y.RADIUS=10;y.MAX_NB=3;y.MIN_AGE_TO_INTERACT=1;y.SENIOR_AGE=100;const J=async()=>{const i=new B,t=z(),s=t.getContext("2d"),n=new D(s);if(!s)throw new Error("no 2d context");const r=t.width=window.innerWidth,e=t.height=window.innerHeight,f=new G;let a=[],c=a[0],u=!0;const l=new y;l.brain.loadFromFile("top");let h=l.brain.score||0;f.play((g,T)=>{var x;t.width=window.innerWidth,t.height=window.innerHeight;const v=new Array(b).fill(0);a.forEach((o,p)=>{v[o.faction]++,m(o),o.update(),o.x>r&&(o.x=0),o.x<0&&(o.x=r),o.y>e&&(o.y=0),o.y<0&&(o.y=e)}),v.forEach((o,p)=>{if(o<y.MAX_NB){const M=a.find(C=>C.faction===p),E=k(0,r),F=k(0,e),O=$(-Math.PI,Math.PI),w=new y({x:E,y:F,a:O,energy:100,faction:p});M&&(w.brain.name=`${M.brain.name} => ${p}`),w.brain.loadFromFile("top"),w.brain.mutationAmount=o/y.MAX_NB/(1+h),w.brain.randomize(),w.brain.score=0,a.push(w)}}),a.forEach(o=>o.updateTargets(a,r,e));const S=a.concat().sort((o,p)=>p.scorediff-o.scorediff);if(window.scores=S,a.forEach(o=>{o.focused=o===S[0],o.draw(s)}),a=a.filter(o=>!o.dead),c=S[0],n.network=(x=a[0])==null?void 0:x.brain,n.entity=a[0],c&&c.brain.score>h){const o=c.brain.score;n.network=c.brain,n.entity=c,console.log(`New score: ${h} > ${o.toFixed()} (+${(o-h).toFixed(3)})`),h=o,c.brain.saveToFile("top")}i.once("KeyV")&&(u=!u),u?n.render():(s.fillStyle="rgba(255, 255, 255, .6)",s.font="24px Arial",s.textAlign="left",s.textBaseline="bottom",s.fillText("Press V for neural network visuals",0,e))});function m(g){const T=[];g.others.forEach(o=>{T.push(o.distance),T.push(o.opportunity)});const[v,S,x]=g.brain.feedForward(T);v&&g.forward(),S&&g.turnLeft(),x&&g.turnRight()}};export{J as default};
