import{B as M,M as S,a as _,c as b,l as f,r as v,L as C,d as P,e as A,V as B,R as W,C as E,S as T,P as N,W as k}from"./math.7f2646da.js";const L=new M,d=.005,I=.8,x=.95,F=.1,z=.1;class G{constructor(t,s){this.path=t,this.onCheckpoint=s,this.x=0,this.y=0,this.a=0,this.vx=0,this.vy=0,this.va=0,this.fuel=100,this.oxygen=100,this.score=0,this._index=0,this.material=new S({color:16711935}),this.mesh=new _(L,this.material),this.mesh.scale.set(1,.3,.1),this.mesh.position.set(this.x,this.y,0)}update(){if(this.x+=this.vx,this.y+=this.vy,this.a+=this.va,this.vx*=x,this.vy*=x,this.va*=x,this.oxygen>0&&(this.oxygen-=z),this.target.isInRange(this.mesh,3)&&(this.score++,this.onCheckpoint(this),this.fuel+=50,this.oxygen+=50,this.targetIndex++),this.isDead())this.material.color.setRGB(128,128,128),this.onCheckpoint(this),this.reset();else{const[t,s]=[b(this.fuel*.01,0,1),b(this.oxygen*.01,0,1)];this.material.color.setRGB(1-t,t,s)}this.mesh.position.set(this.x,this.y,0),this.mesh.rotation.set(0,0,this.a)}normalizedIndex(t=this._index){return t%this.path.segments.length}set targetIndex(t){this._index=this.normalizedIndex(t)}get targetIndex(){return this._index}get target(){return this.path.segments[this.targetIndex]}trustLeft(){this.fuel<0||(this.fuel-=F,this.va-=d*I,this.vx+=Math.cos(this.a)*d,this.vy+=Math.sin(this.a)*d)}trustRight(){this.fuel<0||(this.fuel-=F,this.va+=d*I,this.vx+=Math.cos(this.a)*d,this.vy+=Math.sin(this.a)*d)}waypoint(t=0){let s=this.normalizedIndex(this.targetIndex+t);return this.path.segments[s]}isDead(){return this.oxygen<=0}reset(){this.targetIndex=0,this.vx=0,this.vy=0,this.va=0,this.x=0,this.y=0,this.a=0,this.fuel=100,this.oxygen=100,this.score=0,this.ctrl.brain.randomize()}}class ${constructor(t){this.weight=0,this.bias=0,Object.assign(this,t)}}class w{constructor(t,s=1,e=[5],i=0,n=0){this.inputs=t,this.outputs=s,this.hiddenLayers=e,this.generation=i,this.mutationAmount=n,this.layers=[],this.score=0,this.name=`Network ${[this.inputs,...this.hiddenLayers,this.outputs].join(".")}`,this.layers=[t,...e,s].map(r=>new Array(r).fill(0).map(()=>new $({bias:0,weight:0}))),this.randomize(1)}loadFromFile(t){const s=localStorage.getItem(t),e=JSON.parse(s);return this.fromObject(e),e}saveToFile(t){localStorage.setItem(t,this.toJSON())}fromObject(t){Object.assign(this,t)}toJSON(){const t={score:this.score,generation:this.generation,layers:this.layers};return JSON.stringify(t,null,2)}train(t,s=1e3){const e=[];for(let i=1;i<=s;i++){const[n,r]=t(),u=this.clone(i/s),c=this.feedForward(n),p=r.reduce((g,y)=>g+Math.abs(r[y]-c[y]),0);console.log({inputs:n,expected:r,results:c,distance:p}),e.push({network:u,mutation:u.mutationAmount,distance:p})}return e.sort((i,n)=>i.distance-n.distance),console.table(e.map(i=>i.distance)),e}clone(t=this.mutationAmount){return new w(this.inputs,this.outputs,this.hiddenLayers,this.generation+1,t)}feedForward(t,s=0){const e=this.layers[s];if(!e)return t;const i=e.map(n=>t.reduce((r,u)=>{const c=n.weight*u;return c>n.bias?c:r},0));return this.feedForward(i,s+1)}randomize(t=this.mutationAmount){for(let s=0;s<this.layers.length;s++){const e=this.layers[s];for(let i=0;i<e.length;i++){const n=e[i];n.bias=f(n.bias,v(-1,1),t),n.weight=f(n.weight,v(-1,1),t)}}}sigmoid(t){return 1/(1+Math.exp(-t))}sigmoidPrime(t){return this.sigmoid(t)*(1-this.sigmoid(t))}}const O=2,R="waypoints_neural_8_2";class j{constructor(t,s){this.mob=t,this.pad=s,this.brain=new w(8,2,[8,4]),this.material=new C({color:s?16768290:16755200});const e=[];for(let i=0;i<O+1;i++)e.push(new B(0,0,0));this.geometry=new P().setFromPoints(e),this.mesh=new A(this.geometry,this.material),this.brain.loadFromFile(R)}generateInputs(){const t=this.mob.waypoint(0),s=this.mob.waypoint(1),e=t.x,i=t.y,n=s.x,r=s.y;return[e,i,n,r,this.mob.vx,this.mob.vy,this.mob.va,this.mob.a]}update(){const t=this.mesh.geometry.attributes.position.array;t[0]=this.mob.mesh.position.x,t[1]=this.mob.mesh.position.y,t[2]=0;for(let n=0;n<O;n++){const r=this.mob.waypoint(n);t[(n+1)*3]=r.x,t[(n+1)*3+1]=r.y,t[(n+1)*3+2]=0}this.mesh.geometry.attributes.position.needsUpdate=!0,this.mob.fuel<=0&&this.material.color.setRGB(128,128,128);const s=this.generateInputs(),[e,i]=this.brain.feedForward(s);i>=1&&this.mob.trustRight(),e>=1&&this.mob.trustLeft()}setWinner(){this.brain.saveToFile(R)}}class J{constructor(t=[]){this.segments=t}update(){this.segments.forEach(t=>t.update())}}const U=new W,H=new S({color:35071,opacity:.5});class V{constructor(t,s){this.x=t,this.y=s,this.clock=new E,this.mesh=new _(U,H),this.mesh.scale.set(.2,.2,.02),this.mesh.position.x=t,this.mesh.position.y=s}isInRange(t,s=.1){return t!=null&&t.position?t.position.distanceTo(this.mesh.position)<s:!1}update(){}}const D={paths:[{spawns:["monsterA","monsterB"],segments:[[-14,0],[-17,-2],[-11,-9],[10,11],[13,12],[17,13],[23,14],[18,15],[13,16]]}]},X=1e3,K=()=>{let h=0;const t=new T,s=D.paths.map(o=>{const a=new J(o.segments.map(([l,m])=>new V(l,m)));return a.segments.forEach(l=>t.add(l.mesh)),a}),e=new N(75,window.innerWidth/window.innerHeight,.1,1e3);e.position.z=25,e.position.y=-8,e.rotation.x=Math.PI*.2;const i=new k;i.setSize(window.innerWidth,window.innerHeight);const n=i.domElement;document.body.appendChild(n);const r=[],u=[],c=X;console.log({EXP_MOBS_NB:c}),s.forEach(o=>{for(var a=0;a<c;a++){const l=new G(o,y);t.add(l.mesh),r.push(l);const m=new j(l);a===0&&(h=m.brain.score),m.brain.score=0,l.ctrl=m,m.brain.mutationAmount=f(0,1/(1+h),a/c),m.brain.randomize(),u.push(m),t.add(m.mesh)}});const p=new E;console.log(`Starting score at ${h}`);function g(){requestAnimationFrame(g),p.getElapsedTime()*.1*Math.PI,e.position.set(-0,-25,25),i.render(t,e),s.forEach(o=>o.update()),r.forEach(o=>o.update()),u.forEach(o=>o.update())}g();function y(o){const a=o.score*1e3+o.fuel;h<a&&(o.ctrl.brain.score=a,console.log(`score change ${h} > ${a}'

Fuel: ${o.fuel.toFixed(2)}

Oxygen: ${o.oxygen.toFixed(2)}

Waypoints: ${o.score}`),h=a,o.ctrl.setWinner())}};export{K as default};
