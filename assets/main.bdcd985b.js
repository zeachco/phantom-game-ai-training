import{c as P}from"./dom.be162d4e.js";import{GamePad as F}from"./Gamepad.8a108b30.js";import{l as S,r as b,v as M,c as T,d as N,b as R}from"./three.module.3aad9aee.js";import{GameLoop as D}from"./GameLoop.1fe23b1e.js";class C{constructor(s){this.weight=0,this.bias=0,Object.assign(this,s)}}class A{constructor(s,e=1,a=[5],n=0,o=0){this.inputs=s,this.outputs=e,this.hiddenLayers=a,this.generation=n,this.mutationAmount=o,this.layers=[],this.score=0,this.layers=[s,...a,e].map(r=>new Array(r).fill(0).map(()=>new C({bias:0,weight:0}))),this.randomize(1)}loadFromFile(s){const e=localStorage.getItem(s),a=JSON.parse(e);return this.fromObject(a),a}saveToFile(s){localStorage.setItem(s,this.toJSON())}fromObject(s){Object.assign(this,s)}toJSON(){const s={score:this.score,generation:this.generation,layers:this.layers};return JSON.stringify(s,null,2)}train(s,e=1e3){const a=[];for(let n=1;n<=e;n++){const[o,r]=s(),h=this.clone(n/e),c=this.feedForward(o),g=r.reduce((f,m)=>f+Math.abs(r[m]-c[m]),0);console.log({inputs:o,expected:r,results:c,distance:g}),a.push({network:h,mutation:h.mutationAmount,distance:g})}return a.sort((n,o)=>n.distance-o.distance),console.table(a.map(n=>n.distance)),a}clone(s=this.mutationAmount){return new A(this.inputs,this.outputs,this.hiddenLayers,this.generation+1,s)}feedForward(s,e=0){const a=this.layers[e];if(!a)return s;const n=a.map(o=>s.reduce((r,h)=>{const c=o.weight*h;return c>o.bias?c:r},0));return this.feedForward(n,e+1)}randomize(s=this.mutationAmount){for(let e=0;e<this.layers.length;e++){const a=this.layers[e];for(let n=0;n<a.length;n++){const o=a[n];o.bias=S(o.bias,b(-1,1),s),o.weight=S(o.weight,b(-1,1),s)}}}}const l=class{constructor(t={}){this.label="",this.x=0,this.y=0,this.a=0,this.va=0,this.s=0,this.focused=!1,this.dead=!1,this.enemies=[],this.energy=100,this.atk=0,this.vatk=0,this.brain=new A(l.TRACK_NB*3,4),Object.assign(this,t)}attack(){this.dead||this.atk>1||(this.energy-=10,this.vatk=20,this.brain.score-=1)}forward(){this.s+=.03,this.brain.score-=.01}turnLeft(){this.va-=Math.min(.05,1/this.radius)}turnRight(){this.va+=Math.min(.05,1/this.radius)}get radius(){return l.RADIUS}update(){this.s*=.99,this.va*=.7,this.vatk*=.9,this.atk=(this.atk+this.vatk)*.7,!this.dead&&(this.energy-=this.s/50,this.energy-=this.va/100,this.x+=Math.cos(this.a)*this.s,this.y+=Math.sin(this.a)*this.s,this.a+=this.va,this.a>Math.PI&&(this.a-=Math.PI*2),this.a<-Math.PI&&(this.a+=Math.PI*2))}updateEnemies(t){if(this.enemies=[],!this.dead){for(let s=0;s<t.length;s++){const e=t[s];if(e===this||e.dead)continue;const[a,n]=this.projectedPosition(),[o,r]=e.projectedPosition(),h=M(a-e.x,n-e.y),c=M(this.x-o,this.y-r);h<this.mouthSize+e.radius&&this.eat(e);const[g,f]=this.relativePosition(e),m=N(g,f),w=T(this.a,m);this.enemies.push({ref:e,distance:h,relativeAngle:w,mouthDistance:c})}this.enemies.sort((s,e)=>s.distance-e.distance)}}draw(t){this.focused&&this.drawRelations(t);const s=Math.PI*S(.15,.4,this.atk/50);this.dead?(t.fillStyle="rgba(255, 255, 255, .05)",t.strokeStyle="rgba(255, 255, 255, .25)"):(t.strokeStyle="rgba(255, 255, 255, .8)",t.fillStyle=this.focused?"rgba(255, 128, 128, .8)":"rgba(0, 128, 128, .8)"),t.save(),t.translate(this.x,this.y),t.rotate(this.a),t.beginPath(),t.moveTo(0,0),t.arc(0,0,this.radius,s,Math.PI*2-s),t.lineTo(0,0),t.arc(this.attkRange,0,this.mouthSize,s,Math.PI*2-s),t.lineTo(0,0),t.stroke(),t.fill(),t.restore(),this.drawScore(t)}get mouthSize(){return this.attkRange/4}get attkRange(){return this.radius+this.atk}drawRelations(t){t.setLineDash([7,3]),t.lineWidth=2,this.enemies.slice(0,l.TRACK_NB).forEach((s,e)=>{const a=1-e/l.TRACK_NB;t.beginPath();const[n,o]=this.projectedPosition();s.distance<=s.mouthDistance?t.strokeStyle=`rgba(0, 128, 0, ${a})`:t.strokeStyle=`rgba(255, 128, 0, ${a})`,t.moveTo(n,o),t.strokeStyle=`rgba(0, 128, 0, ${a})`,t.lineTo(s.ref.x,s.ref.y),t.stroke()}),t.setLineDash([])}projectedPosition(t=this.attkRange){const s=this.x+Math.cos(this.a)*t,e=this.y+Math.sin(this.a)*t;return[s,e]}relativePosition(t){const[s,e]=this.projectedPosition(),a=s-t.x,n=e-t.y;return[a,n]}eat(t){const s=Math.max(this.attkRange,this.atk);t.energy-=s,this.energy+=s;const e=this.s-t.s;this.brain.score+=s*e,t.brain.score-=s*e,t.energy<2&&(t.dead=!0)}drawScore(t){t.fillStyle="white",t.textAlign="center";const s=this.y>l.RADIUS*4?this.y-l.RADIUS*2:this.y+l.RADIUS*2;t.fillText(`${this.label} ${this.brain.score.toFixed()}`,this.x,s)}};let p=l;p.TRACK_NB=10;p.RADIUS=15;p.MAX_NB=10;const L=async()=>{const t=new F,s=P(),e=s.getContext("2d");if(!e)throw new Error("no 2d context");const a=s.width=window.innerWidth,n=s.height=window.innerHeight,o=new D;let r=[],h=r[0],c=0;const g=new p;g.brain.loadFromFile("top");let f=g.brain.score||0;console.log({bestSavedScore:f}),o.play((d,y)=>{if(s.width=window.innerWidth,s.height=window.innerHeight,r.forEach((i,u)=>{i.focused?m(i):w(i),i.x>a&&(i.x=0),i.x<0&&(i.x=a),i.y>n&&(i.y=0),i.y<0&&(i.y=n),i.update()}),r.forEach(i=>i.updateEnemies(r)),r.length<p.MAX_NB)for(let i=0;i<10;i++){const u=new p({a:b(-Math.PI,Math.PI),x:R(0,a),y:R(0,n),energy:b(100,150),label:`${c++}`});u.brain.loadFromFile("top"),u.brain.randomize(i/10),u.brain.score=0,r.push(u)}if(r.forEach(i=>i.draw(e)),r=r.filter(i=>!i.dead),h=r.concat().sort((i,u)=>u.brain.score-i.brain.score)[0],h&&h.brain.score>f){const i=h.brain.score;console.log(`New score: ${f} > ${i.toFixed()} (+${(i-f).toFixed(3)})`),f=i,console.log(`saving top ${h.label}`),h.brain.saveToFile("top")}});function m(d){t.get("ArrowUp")&&d.forward(),t.get("ArrowLeft")&&d.turnLeft(),t.get("ArrowRight")&&d.turnRight(),t.get("Space")&&d.attack()}function w(d){const y=[];d.enemies.forEach(k=>{y.push(k.distance),y.push(k.mouthDistance),y.push(k.relativeAngle)});const[v,i,u,I]=d.brain.feedForward(y);v&&d.forward(),i&&d.turnLeft(),u&&d.turnRight(),I&&d.attack()}};export{L as default};
